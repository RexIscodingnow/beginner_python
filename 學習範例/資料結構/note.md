# 資料結構與演算法 の 筆記

## 事前說明
> 說明: 本檔案為"在學習過程中，所記錄的筆記"，所以在紀錄的過程中，有的是引用書籍內容。
> 可能會有疏忽遺漏掉的部分。


## 註記 (看一下比較好逛內容):
        1. 本筆記是把所有內容，寫在你目前正在看的檔案
        2. 若要直接查看特定內容，若在瀏覽器看本筆記，請按下 Ctrl + F 或是類似功能 (快捷鍵之類)，來查找內容
        3. 實作的程式碼，較多會使用 pseudo code，偶有會使用到 Python or C++ 呈現


## 筆記標題

* 資料結構 Data Structure
    1. 資料結構的定義
         1. 簡介與定義
         2. 資料結構與演算法
         3. 常見的演算法簡介
         4. 演算法的效能分析

    2. 陣列 Array
         1. 陣列簡介
         2. 儲存結構與邏輯圖示
         3. 矩陣
         4. 多項式

    3. 鏈結串列 Linked List
         1. 鏈結串列簡介 (陣列 VS 串列)
         2. 動態配置記憶體
         3. 單向鏈結串列
         4. 環狀鏈結串列
         5. 雙向鏈結串列

    4. 堆疊 Stack
         1. 堆疊簡介 (含實作)
         2. 堆疊的應用
         3. 算術運算式 (表示法與運算式計算)

    5. 佇列 Queue
         1. 佇列簡介
         2. 線性佇列
         3. 環狀佇列
         4. 雙向佇列
         5. 優先佇列
         6. 相關應用

    6. 樹狀結構 Tree
         1. 樹狀結構簡介
         2. 樹的基本說明與專有名詞
         3. 二元樹簡介與特殊二元樹
         4. 儲存方式
         5. 二元樹的走訪 (含節點插入、刪除與二元搜尋樹)
         6. 引線二元樹
         7. 樹的二元樹表示法
         8. 最佳化二元搜尋樹 (延伸二元樹、霍夫曼樹)
         9. AVL 平衡樹
         10. 進階樹狀結構應用

    7. 圖形結構 Graph
         1. 圖形結構簡介
         2. 圖形表示法
         3. 圖形的走訪
         4. 擴張樹
         5. 圖形最短路徑

    8. 排序演算法 Sort
         1. 排序演算法簡介
         2. 內部排序法
         3. 外部排序法

    9. 搜尋演算法 Search
         1. 搜尋演算法簡介
         2. 常見的搜尋演算法
         3. 雜湊搜尋法
         4. 常見的雜湊函數
         5. 碰撞與溢位
---

* 演算法 Algorithm
    1. 效率、分析與量級
    2. 分治法 (各個擊破法) Divide and Conquer
    3. 動態規劃 (Dynamic Programming)
    4. ... (待續)


---

# 資料結構 Data Structure

## 1. 資料結構的定義

### 1. 簡介

資料結構在電腦的程式設計領域中，探討將資料更有組織性的存放到電腦記憶體中，以某種方式組織而成來提升程式的執行效率。 就是一種輔助程式設計最佳化的方法論，不僅考慮到儲存的資料，與彼此之間的關係和運算，其中包含了「演算法 (Algorithm)」、存儲結構、排序、搜尋、樹狀、圖形設計概念與雜湊函數。


註: 以下簡介的文筆 Powered by ChatGPT
~~絕對不是我想偷懶省時間 (拜託別打我)~~

資料結構是計算機科學中的一個重要概念，用於組織和管理數據的方式。它提供了各種不同的結構和操作，以便在計算機程序中有效地存儲、檢索、修改和操作數據。

資料結構可以分為兩大類：基本資料結構和高級資料結構。

基本資料結構包括：

1. 陣列（Array）：一組連續的內存位置，用於存儲相同數據類型的元素。數組的元素可以通過索引來訪問和修改。

2. 鏈結串列（Linked List）：由節點組成的有限集合，每個節點包含數據和指向下一個節點的引用。鏈表的元素在內存中可以是零散分佈的，並通過節點之間的引用連接。


高級資料結構包括：
1. 堆棧（Stack）：一種具有後進先出（LIFO）特性的數據結構。新的元素被添加到頂部，稱為推入（Push），並且最後添加的元素首先被刪除，稱為彈出（Pop）。

2. 佇列（Queue）：一種具有先進先出（FIFO）特性的數據結構。新的元素被添加到佇列的尾部，稱為入列（Enqueue），並且最早添加的元素首先被刪除，稱為出列（Dequeue）。

3. 樹（Tree）：由節點和邊組成的分層結構，用於表示層次關係。常見的樹結構包括二叉樹、二叉搜索樹、平衡二叉樹和B樹。

4. 圖（Graph）：由節點（稱為頂點）和邊組成的結構，用於表示物件之間的關係。圖可以是有向的或無向的，可以是帶權重的或不帶權重的。

5. 哈希表（Hash Table）：根據鍵（Key）和值（Value）之間的映射關係進行數據存儲的結構。通過將鍵映射到一個索引，哈希表實現了高效的查找、插入和刪除操作。

6. 圖表（Graph）：用於表示非線性數據結構的抽象數學模型。圖表由節點（稱為頂點）和邊組成，用於表示頂點之間的關係。

資料結構的選擇取決於特定問題的需求和限制。不同的資料結構具有不同的時間和空間複雜度，因此在選擇時需要考慮到算法的效能需求。資料結構是計算機科學中的基礎，對於設計和優化算法和程序非常重要。

### 2. 定義

1-1. 資料與資訊
> 資料 (Data)，指的是一種未經處理的原始文字、數字、符號、圖形等，所表達出來的只是一種沒有評估價值的基本元素或項目。 例如: 姓名、課表等之類的，可以泛稱是一種資料
> 當資料經過處理 (Process) 過程，譬如: 系統性的整理、歸納甚至進行分析，就成為資訊 (Information)


1-2. 資料的特性

* 基本資料型態 (Primitive Data Type)
    * 不能以其他型態來定義的資料型態，或稱為純量資料型態 (Scalar Data Type)，幾乎所有的程式語言都會提供的一組基本資料
        * Example: C/C++ 的整數 (int), 浮點樹 (float), 字元 (char) 等

* 結構化資料型態 (Structured Data Type)
    * 或稱為虛擬資料型態 (Virtual Data Type)，是一種比基本資料型態更高一層的資料型態
        * Example: 字串 (String), 陣列 (Array), 指標 (Pointer), 串列 (List)、 檔案 (file) 等

* 抽象資料型態 (Abstract Data Type: ADT)
    * 對一種的資料型態而言，可以將其看成是一種值集合，以及在這些值所作的運算，與本身所代表的屬性集合。 至於「抽象化」則是沒有固定的模式，它會隨著需要或實際情況有所不同。
    * ADT 所代表的意義，便是定義這種資料型態所具備的資料與抽象關係，在電腦中是表示一種「資料隱藏 (Information Hiding)」。

        * Example: 堆疊 (Stack)，是一種先進後出 (First In, Last Out) 的運作方式


## 2. 資料結構與演算法

### 1. 簡介

> 資料結構與演算法是程式設計中最基本的內涵。 一個程式能否快速有效率的完成預定任務，取決於是否選對了資料結構，而程式是否能清楚而正確的把問題解決，則取決於演算法。

### 2. 演算法的條件

> 在電腦裡的演算法更是不可或缺的一環，在電腦程式所使用的概念與定義，必須符合 5 個條件:

| 演算法特性 | 內容與說明 |
| :--------- | :---------- |
| 輸入 (Input) | 0 個或多個輸入資料，這些輸入必須有清楚描述或定義 |
| 輸出 (Output) | 至少會有一個輸出結果，不可以沒有輸出結果 |
| 明確性 (Definitenss) | 每一個指令或步驟，必須是簡潔明確且不含糊 |
| 有限性 (Finiteness) | 在有限步驟後一定會結束，不會產生無窮迴圈 |
| 有效性 (Effectiveness) | 步驟清楚可執行，能讓使用者計算、推演求出答案，用紙筆也能推演結果 ~~(人肉計算機)~~ |

### 3. 演算法的表現方式

> 主要是提供給人類閱讀了解流程用的，主要能清楚表達其演算法的流程步驟。
>
> 1. 虛擬碼 (pseudo code，或稱虛擬語言 (pseudo Language))
>
> 2. 表格或圖形: 例如陣列、樹狀圖、矩陣圖等
>
> 3. 流程圖 (Flow Diagram): 使用圖形符號 + 流程方向


* 範例演示: 循序搜尋法 (或叫線性搜尋法)，從要搜尋的連續資料 (Array 之類的資料類型) 開頭第 1 個位置，一路從頭比到尾。
  若找到目標，則中斷迴圈返回結果值
    * 演示呈現: 虛擬碼 (pseudo code)

> 以下只是一種示例，請根據情況自行調整寫法

```js
pseudo code
___________________________________
// param data: 待搜尋資料
// param target: 搜尋目標
function sequential_search(data, target) {
    let i <- 0;   // 宣告變數 i 並指派數值 0

    while ( i to length of data ) do   // 從 i ~ data 的總長度
        
        if ( target is equal to the element of data[i] ) then   // target 等於 在 data 的索引值 i 的元素
            
            return i;
    
    return -1;
}
```

### 4. 演算法的效能分析

對一個程式 (或演算法) 效能的評估，經常是從時間與空間兩種因素作為考量。
在分析一個演算法的效率叫做複雜度 (Complexity)，那從時間方面分析程式的執行時間，稱為「時間複雜度 (Time Complexity)」。
而空間方面分析在電腦記憶體所佔用的空間大小，稱為「空間複雜度 (Complexity)」


* 空間複雜度 Space Complexity
    「空間複雜度」是一種評估所需要的記憶體空間的指標，而這些所需要的記憶體空間，
    
    通常可以分為「固定空間」(包括基本程式碼、常數、變數等) 與「變動空間」(隨著程式執行時會改變大小的空間，例如參考型態變數)。

* 時間複雜度 Time Complexity
    以時間為單位來分析一個演算法的效率，一般不會去求 CPU 週期的真實數值。

    而是求出一個時間成長率 (rate of growth) 的式子，來表達**執行次數**上的**概略的量度層級**，**並非真實的執行次數**

    以 Big-O 表示，O 代表量級 (Order)，寫法: O( 數值 )

        1. 線性搜尋法，複雜度為 O(n)
        2. 泡沫排序法，複雜度為 O(n ^ 2)

    Big-O 是一種表示**最壞執行時間**的情況，也是最常使用在描述 Time Complexity 的漸進式表示法

    以下是 Big-O 常見的各個情況的特色與說明

    | 執行時間 | Big-O (有的書籍叫做 Big-oh) | 特色與說明 |
    | :------: | :------------------------- | :-------- |
    | 快  | O(1) | 稱為**常數時間 (constant time)**，<br>表示演算法的執行時間是一個常數倍 |
    |  ↓  | O(log n) / O(lg n) | 稱為**次線性/對數 時間 (sub-linear / logarithm time)**，<br>成長速度比線性時間還慢，而比常數時間還快 |
    |  ↓  | O(n) | 稱為**線性時間 (linear time)**，<br>成長速度會隨著資料集合的大小，而線性成長 |
    |  ↓  | O(n log n) | 稱為**線性乘對數時間**，<br>成長速度是介於線性及二次方成長之間 |
    |  ↓  | O(n ^ 2) | 稱為**次方時間 (quadratic time)**，演算法的執行時間會以二次方的速度成長 |
    |  ↓  | O(n ^ 3) | 稱為**立方時間 (cube time)**，<br>演算法的執行時間會以三次方的速度成長 |
    |  慢  | O(2 ^ n) | 稱為**指數時間 (exponential time)**，<br>演算法的執行時間會以 2 的 n 次方的速度成長。<br>例如: Nonpolynomial Problem 問題演算法的時間複雜度即為 O(2 ^ n) |

題外話: 獨立於具體硬體限制，重點在評估算法在處理不同資料大小的輸入時，所需要的操作數量或執行時間的成長趨勢。
假如一邊是使用資料中心的超級電腦，而另一邊使用個人電腦 (例如文書電腦，僅能跑得動小遊戲為基準)，執行同一支程式碼的時間效率。 由於兩方電腦的算力差距太大，在分析複雜度中，資料中心的超級電腦本身有更好更大的硬體效能、記憶體空間、存取速度 ; 相反，個人電腦的硬體效能、儲存空間、存取速度比較有限。



## 2. 陣列 Array

### 1. 陣列簡介



